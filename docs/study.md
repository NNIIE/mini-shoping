# Fork Join Pool
- 전통적인 스레드가 멀티코어 CPU를 효율적으로 활용하는데 한계가 있어서 등장
  - why?
    - 전통적인 ThreadPoolExecutor는 멀티코어와 스레드풀이 있는 환경에서도 하나의 공통 작업큐만 사용
      - 모든 스레드가 하나의 큐에서 경쟁적으로 작업을 가져옴
      - 큐에서 큰 작업이 먼저 스케줄링 되면 해당 스레드의 전용작업이 되버려서 완료될때까지 잠기고 다른 스레드도 이를 도울 수 없음
      - 스레드 간 작업 재분배 매커니즘이 없어 어떤건 바쁘고 어떤건 놀고있어도 조정이 불가함
- 장점
  - 워크 스틸링: 각 워커 스레드는 자신의 양뱡향 작업 큐가 있고 작업을 LIFO로 가져오고 큐가 비면 다른 바쁜 스레드의 큐에서 FIFO로 작업을 훔쳐옴
  - 분할 정복: 큰 작업을 처리하는 스레드가 작업을 여러개의 서브 태스크로 나눠서 유휴 스레드에게 나눠줄 수 있음
  - 대용량 데이터 처리, 재귀 분할이 가능한 알고리즘, 독립적인 서브태스크로 분할 가능한 작업, CPU 바운드 작업 등이 적합
- 단점
  - 작은 작업에는 분할/병합의 오버헤드가 더 클 수 있음
  - I/O 작업에 비효율적
    - why?
      - I/O 작업은 블로킹이 되기 때문에 워커스레드 자체가 블로킹 되어버림
      - I/O 작업은 블로킹 되버린 스레드의 작업큐는 다른 스레드에서 작업을 훔쳐갈 수 없음
      - Fork Join Pool은 기본적으로 코어 수에 비례한 스레드를 사용하는데 이는 많은 스레드를 필요로 하는 I/O 작업에 부적합

<br>

# 동시성 / 병렬성

# Virtual Threads

# GC 알고리즘

# MySQL / PostgreSQL / MariaDB

# DDD / Hexagonal

# Unit Test / Integration Test

# Session / Token
