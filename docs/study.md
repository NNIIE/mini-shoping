- [Fork Join Pool](#fork-join-pool)
- [Virtual Threads](#virtual-threads)
- [GC 알고리즘](#gc-알고리즘)
- [MySQL / PostgreSQL / MariaDB](#MVCC-MySQL--PostgreSQL)
- [DDD / Hexagonal](#ddd--hexagonal)
- [Index]()
- [정규화]()
- [Session / Token](#session--token)


<br>


# Fork Join Pool
### 등장배경
- 전통적인 스레드가 멀티코어 CPU를 효율적으로 활용하는데 한계가 있어서 등장
  - why?
    - 전통적인 ThreadPoolExecutor는 멀티코어와 스레드풀이 있는 환경에서도 하나의 공통 작업큐만 사용
      - 모든 스레드가 하나의 큐에서 경쟁적으로 작업을 가져옴
      - 큐에서 큰 작업이 먼저 스케줄링 되면 해당 스레드의 전용작업이 되버려서 완료될때까지 잠기고 다른 스레드도 이를 도울 수 없음
      - 스레드 간 작업 재분배 매커니즘이 없어 어떤건 바쁘고 어떤건 놀고있어도 조정이 불가함
### 장단점
- 장점
  - 워크 스틸링: 각 워커 스레드는 자신의 양뱡향 작업 큐가 있고 작업을 LIFO로 가져오고 큐가 비면 다른 바쁜 스레드의 큐에서 FIFO로 작업을 훔쳐옴
  - 분할 정복: 큰 작업을 처리하는 스레드가 작업을 여러개의 서브 태스크로 나눠서 유휴 스레드에게 나눠줄 수 있음
  - 대용량 데이터 처리, 재귀 분할이 가능한 알고리즘, 독립적인 서브태스크로 분할 가능한 작업, CPU 바운드 작업 등이 적합
- 단점
  - 작은 작업에는 분할/병합의 오버헤드가 더 클 수 있음
  - I/O 작업에 비효율적
    - why?
      - I/O 작업은 블로킹이 되기 때문에 워커스레드 자체가 블로킹 되어버림
      - I/O 작업은 블로킹 되버린 스레드의 작업큐는 다른 스레드에서 작업을 훔쳐갈 수 없음
      - Fork Join Pool은 기본적으로 코어 수에 비례한 스레드를 사용하는데 이는 많은 스레드를 필요로 하는 I/O 작업에 부적합


<br>


# Virtual Threads
### 등장배경
기존 자바의 스레드가 OS 스레드와 1:1 매핑되는 방식의 한계를 해결하기 등장
- 스레드 당 대략 1MB의 스택 메모리 소비
- OS 스레드 간 컨텍스트 스위치 비용이 비쌈
- I/O 작업에서 블로킹 되어버림

### 동작 원리
- OS 스레드가 아닌 JVM이 직접 스레드를 관리
- 캐리어 스레드: 실제 OS 스레드로 가상 스레드를 실행하는 매체
- Continuation: 가상 스레드의 실행 상태를 캡처하고 저장하는 메커니즘. 블로킹 작업이 발생하면 가상 스레드의 상태를 저장하고 carrier 스레드를 해제
- pinning: 가상 스레드가 네이티브 메소드나 synchronized 블록 실행 중이라면 언마운트될 수 없음. 이 상태에서는 일반 OS 스레드처럼 동작
- Mounting/Unmounting: 가상 스레드가 실행을 시작하면 carrier 스레드에 마운트 되고 블로킹 작업에서는 언마운트됩니다.

### flow
1. 가상스레드에서 블로킹 작업 발생
2. 가상 스레드 실행 상태 저장 (Continuation)
3. 캐리어 스레드 해제
4. 블로킹 작업 완료
5. 가상 스레드 재개

### 장단점
- 장점
  - 동시 연결 처리 탁월
    - 스프링 MVC에서 요청마다 가상 스레드가 생성 됨
  - 메모리 효율성 (약 2KB)
  - 기존 블로킹 I/O 코드와 같이 사용 가능
  - 스택 트레이스가 완전히 보존되어 디버깅 용이
- 단점
  - I/O 바운드에는 탁월하지만 CPU 바운드 에서는 여전히 코어 개수가 중요
  - synchronized는 핀닝을 발생시켜 언마운트 안됨 (일반 OS 스레드처럼 블로킹)
  - 많은 가상스레드에서 스레드로컬을 사용하면 메모리 부담
  - 아직 프레임워크/라이브러리에서 최적화 되지 않음
 
### why
비슷한 해결책을 제시하는 리액티브 프로그래밍(web flux)이 있는데 냅두고 왜 나왔지?
- 언어 수준에서 지원하기 위해?
- 러닝커브가 낮고 기존 MVC 코드와의 통합이 용이해서?
  - I/O 비동기 처리 자체를 추상화?
- 스택트레이스가 온전히 존재해 디버깅 하기가 쉬워서?


<br>


# GC 알고리즘
### 동시성의 차이
- 병렬 처리 (Paraller): 여러 GC 스레드가 동시에 GC를 수행하지만 이 동안 Stop-the-world
- 동시 처리 (Concurrent): GC작업이 어플리케이션 스레드와 함께 수행됨. 즉 어플리케이션이 실행되는 동안 GC가 백그라운드에서 실행됨

### 동시성의 trade-off
- 동시성이 높을수록 stop-the-world는 줄어들지만 다른 비용 발생
  - CPU 오버헤드: 동시작업은 GC가 어플리케이션과 CPU 리소스를 공유해야 함
  - 처리량 감소: 동시성이 높을수록 처리량은 감소

### Parallel GC
- 최대 처리량을 목표로 설계
- 병렬로 GC작업을 수행하기 때문에 동시성이 없음
- GC 작업과 어플리케이션의 실행이 동시에 일어나지 않음

### G1 GC
- 동시성과 처리량의 조화를 목표로 설계
- 처음으로 동시성을 도입한 CMS(현재 지원종료) 이후 향상된 부분적인 동시성 제공
- 하지만 일부 중요한 단계에서는 Stop-the-world가 필요함

### ZGC
- 동시성 극대화를 목표로 설계
- 동시성을 극대화함. 거의 모든 GC작업이 어플리케이션 스레드와 동시에 실행
- 마이크로초 단위의 매우 짧은 Stop-the-world가 필요함


<br>


# MVCC (MySQL / PostgreSQL)
### MySQL
- 언두 로그를 사용해 mvcc 구현
- 퍼지 프로세스를 통해 더이상 필요없는 레코드 버전을 정리
- 적합 환경
  - 짧은 트랜잭션과 높은 처리량이 필요할 경우
  - 저장 공간이 제한적이거나 데이터 크기가 매우 큰 경우

### PostgreSQL
- 튜플 버전을 레코드 자체 내에 직접 유지. 모든 update/delete 작업은 새로운 튜플 버전을 생성
- VACCUM 프로세스를 통해 데드 튜플(더이상 어떤 트랜잭션에도 보이지 않는 튜플)을 정리
- 적합 환경
  - 복잡한 쿼리와 분석잡업이 많을 경우
  - 특정 시점의 데이터를 자주 조회해야 하는 경우

| 항목            | MySQL                        | PostgreSQL                                |
|----------------|-------------------------------|--------------------------------------|
| 스토리지 공간 vs 쿼리 유연성     | 언두 로그를 별도 관리하여 테이블 크기는 작지만 과거 데이터 쿼리가 복잡   | 모든 버전을 테이블에 저장하여 테이블 크기는 크지만 과거 데이터 쿼리가 용이  |
| 관리 복잡성        | 언두 로그 정리는 자동화되어 있어 관리가 쉽지만 세부 조정이 제한적             | VACUUM 파라미터를 세밀하게 조정할 수 있지만 관리 복잡성이 증가           | 
| 장기 트랜잭션    | 장기 트랜잭션은 언두 로그 크기를 급격히 증가시켜 성능 저하 유발 | 장기 트랜잭션은 VACUUM 효율성을 저하시켜 테이블 팽창을 유발 | 


<br>


# DDD / Hexagonal
## DDD
### 핵심
1. 기술적 세부사항 보다 비즈니스 도메인에 집중
2. 비즈니스 전문가와 개발자 간의 효율적인 의사소통
3. 대규모 시스템에서 복잡성을 효율적으로 관리

#### 장점
- 도메인 전문가와 개발자 간의 공통 언어(유비쿼터스 언어)를 통해 원활한 커뮤니케이션
- 바운디드 컨텍스트로 대규모 시스템을 작은 규모로 분할
- 도메인 모델이 실제 비즈니스를 반영하므로 유지보수에 용이
- 핵심 비즈니스 로직이 외부 의존성과 분리되어 있어 단위테스트에 용이

#### 단점
- 개념과 패턴을 이해하는데 러닝커브가 높음
- 도메인 모델을 구성하는 과정에서 초기 개발 속도가 느림
- 단순 CRUD, 단순한 비즈니스 도메인의 경우 오버 엔지니어링

## 헥사고날 아키텍처
### 핵심
1. 비즈니스 로직이 데이터베이스, UI, 외부 서비스 등 기술적 구현에 종속되는 문제 해결
2. 외부 시스템과 강하게 연결되어있어 단위/통합테스트의 어려움 해결
3. 특정 기술(데이터베이스, 프레임워크 등)을 변경할때 비즈니스 로직까지 변경해야 하는 경우를 해결

#### 장점
- 외부 의존성으로부터 도메인 로직을 격리하고 보호함으로써 외부 시스템 변경 시 영향 최소화
- 외부 의존성에 대한 모킹으로 핵심로직에 대한 테스트 용이
- 포트와 어댑터에 대한 개별적인 테스트 용이
- 비즈니스 로직, 입력, 출력이 명확하게 분리됨

#### 단점
- 개념과 패턴을 이해하는데 러닝커브가 높고 코드량 증가
- 포트와 어댑터라는 추가적인 추상화 계층으로 인해 코드 복잡성 증가
- 간단한 어플리케이션에서는 오버 엔지니어링


<br>


# Index (MySQL / PostgreSQL)
데이터베이스 테이블의 검색속도를 향상시키기 위한 자료구조. 

## 구조
### B-Tree
- 모든 노드에 키와 데이터를 함께 저장
- 각 노드는 자식 노드를 가리키는 포인터만 보유, 부모 노드를 통해서만 형제 노드 접근 가능
- 키를 찾는 즉시 어느 레벨에서든 검색 종료 가능

#### 검색
- 일반 검색에 유리, 범위 검색에 불리

#### 삽입/삭제
- 삽입: 적절한 위치를 찾아 키와 데이터를 삽입, 필요시 노드 분할
- 삭제: 키를 찾아 제거, 필요시 노드 병합 또는 분할

#### 공간 활용
- 동일한 데이터에 대해 B+Tree보다 트리 높이가 낮을 수 있음
- 각 노드가 키와 데이터를 저장하므로 노드 크기가 클 수 있음

### B+Tree
- 내부 노드에는 키만 저장하고 모든 데이터는 리프노드에 저장
- 모든 리프노드는 연결리스트로 연결되어서 순차적/범위 스캔에 매우 효율적, 리프노드에서 직접 다음/이전 노드 접근 가능
- 항상 리프 노드까지 탐색해야 함

#### 검색
- 범위 검색에 유리, 일반 검색에 불리

#### 삽입/삭제
- 항상 리프노드에 삽입, 필요시 노드 분할 및 내부 노드 갱신
- 항상 리프노드에서만 삭제, 필요시 병합 또는 재분배

#### 공간 활용
- 내부 노드는 키와 포인터만 저장하므로 더 많은 키를 저장 가능
- 동일한 데이터에 대해 B-Tree보다 트리 높이가 높을 수 있음

## MySQL
- InnoDB 스토리지 엔진: B+Tree 인덱스 구조 사용
- 클러스터드 인덱스: PK는 항상 클러스터드 B+Tree 인덱스로 구현
- 보조 인덱스: 리프 노드에 실제 레코드 대신 기본 키 값을 저장하는 B+Tree 구조

## PostgreSQL
- B-Tree 구조를 변형한 형태 사용
- 힙 구조: 테이블 데이터는 힙(Heap) 파일에 저장되고, 인덱스는 TID(Tuple Identifier)를 통해 참조

### 카티덜리티 원칙
- 카디널리티가 인덱스 효율성의 핵심
- pk, 이메일, 주민등록번호 등의 많은 고유값을 가질수록 높은 카디널리티

<br>


# Session / Token




















