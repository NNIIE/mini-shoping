- [MVCC (MySQL / PostgreSQL)](#mvcc-mysql--postgresql)
- [Index (MySQL / PostgreSQL)](#index-mysql--postgresql)
- [정규화](#정규화)


<br>


# MVCC (MySQL / PostgreSQL)
### MySQL
- 언두 로그를 사용해 mvcc 구현
- 퍼지 프로세스를 통해 더이상 필요없는 레코드 버전을 정리
- 적합 환경
    - 짧은 트랜잭션과 높은 처리량이 필요할 경우
    - 저장 공간이 제한적이거나 데이터 크기가 매우 큰 경우

### PostgreSQL
- 튜플 버전을 레코드 자체 내에 직접 유지. 모든 update/delete 작업은 새로운 튜플 버전을 생성
- VACCUM 프로세스를 통해 데드 튜플(더이상 어떤 트랜잭션에도 보이지 않는 튜플)을 정리
- 적합 환경
    - 복잡한 쿼리와 분석잡업이 많을 경우
    - 특정 시점의 데이터를 자주 조회해야 하는 경우

| 항목            | MySQL                        | PostgreSQL                                |
|----------------|-------------------------------|--------------------------------------|
| 스토리지 공간 vs 쿼리 유연성     | 언두 로그를 별도 관리하여 테이블 크기는 작지만 과거 데이터 쿼리가 복잡   | 모든 버전을 테이블에 저장하여 테이블 크기는 크지만 과거 데이터 쿼리가 용이  |
| 관리 복잡성        | 언두 로그 정리는 자동화되어 있어 관리가 쉽지만 세부 조정이 제한적             | VACUUM 파라미터를 세밀하게 조정할 수 있지만 관리 복잡성이 증가           | 
| 장기 트랜잭션    | 장기 트랜잭션은 언두 로그 크기를 급격히 증가시켜 성능 저하 유발 | 장기 트랜잭션은 VACUUM 효율성을 저하시켜 테이블 팽창을 유발 | 


<br>

# Index (MySQL / PostgreSQL)
데이터베이스 테이블의 검색속도를 향상시키기 위한 자료구조.

## 구조
### B-Tree
- 모든 노드에 키와 데이터를 함께 저장
- 각 노드는 자식 노드를 가리키는 포인터만 보유, 부모 노드를 통해서만 형제 노드 접근 가능
- 키를 찾는 즉시 어느 레벨에서든 검색 종료 가능

#### 검색
- 일반 검색에 유리, 범위 검색에 불리

#### 삽입/삭제
- 삽입: 적절한 위치를 찾아 키와 데이터를 삽입, 필요시 노드 분할
- 삭제: 키를 찾아 제거, 필요시 노드 병합 또는 분할

#### 공간 활용
- 동일한 데이터에 대해 B+Tree보다 트리 높이가 낮을 수 있음
- 각 노드가 키와 데이터를 저장하므로 노드 크기가 클 수 있음

### B+Tree
- 내부 노드에는 키만 저장하고 모든 데이터는 리프노드에 저장
- 모든 리프노드는 연결리스트로 연결되어서 순차적/범위 스캔에 매우 효율적, 리프노드에서 직접 다음/이전 노드 접근 가능
- 항상 리프 노드까지 탐색해야 함

#### 검색
- 범위 검색에 유리, 일반 검색에 불리

#### 삽입/삭제
- 항상 리프노드에 삽입, 필요시 노드 분할 및 내부 노드 갱신
- 항상 리프노드에서만 삭제, 필요시 병합 또는 재분배

#### 공간 활용
- 내부 노드는 키와 포인터만 저장하므로 더 많은 키를 저장 가능
- 동일한 데이터에 대해 B-Tree보다 트리 높이가 높을 수 있음

## MySQL
- InnoDB 스토리지 엔진: B+Tree 인덱스 구조 사용
- 클러스터드 인덱스: PK는 항상 클러스터드 B+Tree 인덱스로 구현
- 보조 인덱스: 리프 노드에 실제 레코드 대신 기본 키 값을 저장하는 B+Tree 구조

## PostgreSQL
- B-Tree 구조를 변형한 형태 사용
- 힙 구조: 테이블 데이터는 힙(Heap) 파일에 저장되고, 인덱스는 TID(Tuple Identifier)를 통해 참조

### 카티덜리티 원칙
- 카디널리티가 인덱스 효율성의 핵심
- pk, 이메일, 주민등록번호 등의 많은 고유값을 가질수록 높은 카디널리티


<br>


# 정규화
## 목적
- 데이터 중복 최소화
- 데이터 무결성 향상
- 데이터베이스 구조의 유연성 확보

## 용어
### 함수적 종속성
속성 집합 X가 속성 집합 Y를 결정하면 Y는 X에 함수적으로 종속되어있다. X → Y
즉, 학번이 학생이름을 결정한다면 학생이름은 학번에 함수적으로 종속되어 있다.

### 이행적 종속성
A → B, B → C 일 때, A → C가 성립한다.

### 결정자와 종속자
- 결정자: 다른 속성을 결정하는 속성 (X → Y 에서 X)
- 종속자: 다른 속성에 의해 결정되는 속성 (X → Y 에서 Y)

### Key
- 식별 키
    - 각 레코드를 고유하게 식별할 수 있는 속성 또는 속성의 집합
- 후보 키
    - 테이블에서 각 레코드를 고유하게 식별할 수 있는 최소 속성의 집합, 기본 키로 사용할 수 있는 후보들
- 기본 키
    - 테이블의 각 레코드를 고유하게 식별하기 위해 선택된 후보 키 중 하나
- 대체 키
    - 후보키 중 기본키로 선택되지 않은 나머지 후보키들
- 외래 키
    - 다른 테이블의 기본 키를 참조하는 속성, 테이블 간의 관계를 설정한다.

## 제 1 정규화 (1NF)

모든 속성이 원자적(atomic) 값만을 가져야 한다. 즉, 각 필드에는 하나의 값만 존재해야 한다.

## 제 2 정규화 (2NF)
제1 정규화를 완료한 테이블에서, 부분 함수 종속성을 제거하는 과정
즉, 현재 테이블의 주제와 관련없는 컬럼을 다른 테이블로 빼는 작업
- 기존 테이블: (회원 ID, 회원 주소, 상품 코드, 상품명, 가격)
- 정규화 실행
    - 회원: (회원 ID, 회원 이름, 회원 주소)
    - 상품: (상품 코드, 상품명, 가격)
    - 구매: (회원 ID, 상품코드)

## 제 3 정규화 (3NF)
제2 정규화를 완료한 테이블에서, 이행적 함수 종속성을 제거하는 과정
A → B, B → C 일 때, A → C가 되면 안된다.
- 기존 테이블: 학생(학번, 이름, 학과코드, 학과명, 학과사무실)
    - 학과명, 학과사무실 → 학과코드에 종속
    - 학과코드 → 학번에 정속
    - 정규화 실행
        - 학생(학번, 이름, 학과코드)
        - 학과(학과코드, 학과명, 학과사무실)

## **BCNF 정규화**
제3 정규화를 완료한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

## 장점
- 데이터 일관성 향상: 동일한 데이터가 여러 곳에 중복되지 않으므로 업데이트 시 모든 곳을 변경해야 하는 부담이 없고 이는 데이터 불일치 가능성을 크게 줄인다.
- 업데이트 이상현상 제거
    - 삽입 이상: 관련 없는 데이터까지 함께 입력해야 하는 문제
    - 삭제 이상: 의도치 않게 필요한 데이터까지 삭제되는 문제
    - 수정 이상: 일부만 수정되어 데이터 불일치가 발생하는 문제
- 스키마 유연성 증가

## 단점
- 조인 증가로 인한 성능 저하
- 설계 복잡성 증가
- 직관성 감소

## 반정규화
정규화된 데이터 모델에 중복을 의도적으로 다시 도입하여 성능을 개선하는 기법. 데이터 일관성과 성능 사이의 균형을 조정하는 과정


<br>
